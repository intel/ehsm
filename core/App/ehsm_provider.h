/*
 * Copyright (C) 2020-2021 Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in
 *      the documentation and/or other materials provided with the
 *      distribution.
 *   3. Neither the name of Intel Corporation nor the names of its
 *      contributors may be used to endorse or promote products derived
 *      from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef EHSM_RPOVIDER_H
#define EHSM_PROVIDER_H

#include "common_ehsm.h"

typedef enum _ra_msg_type_t
{
     TYPE_RA_MSG0 = 0,
     TYPE_RA_MSG1,
     TYPE_RA_MSG2,
     TYPE_RA_MSG3,
     TYPE_RA_ATT_RESULT,
     TYPE_RA_RETRIEVE_DK,
}ra_msg_type_t;

#ifndef SAFE_FREE
#define SAFE_FREE(ptr) {if (NULL != (ptr)) {free(ptr); (ptr) = NULL;}}
#endif

const char prov_ip_addr[] = "127.0.0.1";
const uint32_t prov_port = 8887;

#pragma pack(1)

typedef struct _ra_samp_request_header_t{
    uint8_t  type;     /* set to one of ra_msg_type_t*/
    uint32_t size;     /*size of request body*/
    uint8_t  align[3];
    uint8_t body[];
} ra_samp_request_header_t;

typedef struct _ra_samp_response_header_t{
    uint8_t  type;      /* set to one of ra_msg_type_t*/
    uint8_t  status[2];
    uint32_t size;      /*size of the response body*/
    uint8_t  align[1];
    uint8_t  body[];
} ra_samp_response_header_t;

typedef struct sample_key_blob_t {
    uint32_t        blob_size;
    uint8_t         blob[];
} sample_key_blob_t;

#pragma pack()


namespace EHsmProvider
{
    EH_RV Initialize();

    void Finalize();

    /*
    Description:
    Generates EGK and encrypts it with DK.
    Or
    Generates CIWK key pair and encrypts its private key with DK.

    Input:
    Key spec
    Origin

    Output:
    EGK encrypted with DK
    Or
    CIWK key pair (private key encrypted with DK)

    Note: Key types and operations supported by symmetric and asymmetric EGKs
    */
    EH_RV CreateKey(EH_MECHANISM_TYPE ulKeySpec, EH_KEY_ORIGIN eOrigin,
            EH_KEY_BLOB_PTR pKeyBlob);

    /*
    Description:
    Encrypt an arbitrary set of bytes using the DEK derived from the provided EGK or CGK.

    Input:
    EGK or CGK encrypted with DK
    Plaintext to be encrypted

    Output:
    Ciphertext

    Note: Only data of 6KB or less can be encrypted
    */
    EH_RV Encrypt(EH_MECHANISM_PTR pMechanism, EH_KEY_BLOB_PTR pKeyBlob,
            EH_BYTE_PTR pData, EH_ULONG ulDataLen,
            EH_BYTE_PTR pEncryptedData, EH_ULONG_PTR pulEncryptedDataLen);

    /*
    Description:
    Decrypts ciphertext using the DEK derived from the provided EGK or CGK.

    Input:
    EGK or CSK encrypted with DK
    Ciphertext.

    Output:
    Plaintext
    */
    EH_RV Decrypt(EH_MECHANISM_PTR pMechanism, EH_KEY_BLOB_PTR pKeyBlob,
            EH_BYTE_PTR pEncryptedData, EH_ULONG ulEncryptedDataLen,
            EH_BYTE_PTR pData, EH_ULONG_PTR pulDataLen);

    /*
    Description:
    ehsm-core enclave generates a random AES key (128/256bit) as DataKey, then a
    CiphertextBlob is generated by encrypting this DataKey with a specified symmetric CMK.
    Both the plaintext of DataKey and CiphertextBlob are returned to caller.

    Intputs:
    pMechanism -- keyspec(aes-gcm-128) and the aad datas used for the AES encryption/decryption.
    pMasterKeyBlob -- a specified symmetric CMK.
    ulPlainDataKeyLen -- the length of the plaintext.

    Outputs:
    pPlainDataKey -- the pointer of the plaintext of the datakey.
    pEncryptedDataKey -- the pointer of the ciphertext of the datakey.
    pulEncryptedDataKeyLen -- the pointe of the length of the ciphertext.

    Notes:
    Typically, if the size of data file is larger than 6K, it won’t be encrypted/decrypted
    it in the KMS internally, however, you can use the CDK(generated in the eHSM) outside
    of the KMS to encrypt/decrypt the large amount of plaintext data then you need to remove
    it from memory as soon as possible. When trying to decrypt the data, the customer needs
    to pass the encrypted CDK to eHSM to get its plaintext CDK, and using the plaintext CDK
    to decrypt the data also then she/he needs to remove the plaintext CDK from memory after
    use as soon as possible.
    */
    EH_RV GenerateDataKey(EH_MECHANISM_PTR pMechanism,
            EH_KEY_BLOB_PTR pMasterKeyBlob,
            EH_BYTE_PTR pPlainDataKey, EH_ULONG ulPlainDataKeyLen,
            EH_BYTE_PTR pEncryptedDataKey, EH_ULONG_PTR pulEncryptedDataKeyLen);

    /*
    Description:
    The same as GenerateDataKey in previous page, but doesn’t return plaintext of generated DataKey.
    */
    EH_RV GenerateDataKeyWithoutPlaintext(EH_MECHANISM_PTR pMechanism,
            EH_KEY_BLOB_PTR pMasterKeyBlob, EH_ULONG ulPlainDataKeyLen,
            EH_BYTE_PTR pEncryptedDataKey, EH_ULONG_PTR pulEncryptedDataKeyLen);

    /*
    Description:
    ehsm-core enclave will decrypt user-supplied ciphertextblob with specified CMK to get the
    plaintext of DataKey, then use the user-supplied Public key to encrypt this DataKey
    (aka ExportedDataKey). This ExportedDataKey (ciphertext) will be returned to caller.

    Intputs:
    pMechanism -- keyspec(aes-gcm-128) and the aad datas used for the AES encryption/decryption.
    pUsrKeyBlob -- a user-supplied keyblob.
    pMasterKeyBlob -- the specified CMK used to encrypt/decrypt the datakey.
    pEncryptedDataKey -- the pointer of the original ciphertext of the datakey wraped with the CMK.
    ulEncryptedDataKeyLen -- the length of the original ciphertext.


    Outputs:
    pEncryptedDataKey_new -- the new cihpertext of Datakey encrypted with user publicKeyblob.
    pulEncryptedDataKeyLen_new -- the length of the new ciphertext.
    */
    EH_RV ExportDataKey(EH_MECHANISM_PTR pMechanism,
            EH_KEY_BLOB_PTR pUsrKeyBlob, EH_KEY_BLOB_PTR pMasterKeyBlob,
            EH_BYTE_PTR pEncryptedDataKey, EH_ULONG ulEncryptedDataKeyLen,
            EH_BYTE_PTR pEncryptedDataKey_new, EH_ULONG_PTR pulEncryptedDataKeyLen_new);

    /*
    Description:
    Performs an ECDSA or RSA sign operation using the provided EGK or CGK.

    Input:
    pMechanism -- the keyspec type(currently only support RSA3072).
    pKeyBlob -- an EGK or CGK encrypted with DK.
    pData -- the digest of the data that want to be signed.
    ulDataLen -- the length of the digest.

    Output:
    pSignature -- The pointer of the calculated signature value.
    pulSignatureLen -- the length of the signature.
    */
    EH_RV Sign(EH_MECHANISM_PTR pMechanism, EH_KEY_BLOB_PTR pKeyBlob,
               EH_BYTE_PTR pData, EH_ULONG ulDataLen,
               EH_BYTE_PTR pSignature, EH_ULONG_PTR pulSignatureLen);

    /*
    Description:
    Performs an ECDSA or RSA verify operation using the provided EGK or CSK.

    Input:
    pMechanism -- the keyspec type(currently only support RSA3072).
    pKeyBlob -- an EGK or CGK encrypted with DK.
    pData -- the digest of the data that want to be verified.
    ulDataLen -- the length of the digest.
    pSignature -- The pointer of the calculated signature value.
    ulSignatureLen -- the length of the signature.

    Output:
    result -- True or False: indicate whether the signature passed the verification.
    */
    EH_RV Verify(EH_MECHANISM_PTR pMechanism, EH_KEY_BLOB_PTR pKeyBlob,
                 EH_BYTE_PTR pData, EH_ULONG ulDataLen,
                 EH_BYTE_PTR pSignature, EH_ULONG ulSignatureLen, bool* result);
}

#endif
