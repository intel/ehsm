use async_trait::async_trait;
use anyhow::Result;

#[async_trait]
pub trait KMS {
/*
Description:
Create a customer master key(CMK) for the user, 
which can be a symmetric or an asymmetric key, 
for the symmetric cmk mainly used to wrap the datakey, 
also can be used to encrypted an arbitrary set of bytes data(<6KB). 
And for the asymmetric cmk mainly used to sign/verify 
or asymmetric encrypt/decrypt datas(not for the datakey.)
Input:
keyspec -EH_AES_GCM_128,
        -EH_AES_GCM_256,
        -EH_RSA_2048,
        -EH_RSA_3072,
        -EH_EC_P256,
        -EH_EC_P521,
        -EH_SM2,
        -EH_SM4_CBC,
        -EH_HMAC,
origin  -EH_INTERNAL_KEY (generated from the eHSM inside)
        -EH_EXTERNAL_KEY (generated by the customer and want to import into the eHSM),  
purpose -EH_PURPOSE_ENCRYPT_DECRYPT,
        -EH_PURPOSE_SIGN_VERIFY,
padding_mode -EH_PAD_RSA_PKCS1_PSS,
                -EH_PAD_RSA_PKCS1,
                -EH_PAD_RSA_PKCS1_OAEP,
                -EH_PAD_RSA_NO
digest_mode -EH_SHA_2_224,
            -EH_SHA_2_256,
            -EH_SHA_2_384,
            -EH_SHA_2_512,
            -EH_SM3,
Output:
keyid -- A uinque keyid of the cmk.
*/
    async fn create_key(
        &mut self,
        keyspec: &str,
        origin: &str,
        purpose: Option<&str>,
        padding_mode: Option<&str>,
        digest_mode: Option<&str>) -> Result<String>;
/*
Description:
Get public key from keypair.
Input:
keyid    -- A uinque keyid of the cmk.
Output:
pubkey  -- the data of the public key.
*/
    async fn get_publickey(&mut self, _keyid: &str) -> Result<String>;
/*
Description:
Performs sign operation using the cmk(only support asymmetric keyspec).
Input:
keyid    -- A unique keyid of asymmetric cmk.
digest   -- The hash of datas want to be signed, and stored in BASE64 string.
Output:
signature -- The calculated signature value stores in BASE64 string.
*/
    async fn sign(&mut self, _keyid: &str, _digest: &str) -> Result<String>;
/*
Description:
Performs verify operation using the cmk(only support asymmetric keyspec).
Input:
keyid    -- A unique keyid of asymmetric cmk.
digest   -- The hash of datas want to be signed, and stored in BASE64 string.
signature -- The signature of the digest signed by the cmk in BASE64 string.
Output:
result  -- True or False: indicate whether the signature passed the verification.
*/
    async fn verify(&mut self, _keyid: &str, _digest: &str, _signature: &str) -> Result<bool>;
/*
Description:
Decrypt an arbitrary set of bytes using the CMK.(only support symmetric types).
Input:
keyid    -- The keyid of the symmetric cmk which used to decryt the ciphertext.
aad_b64  -- Some extra datas input by the user, which could help to to ensure data integrity, 
            and not be included in the cipherblobs. The aad stored in BASE64 string.
data_b64 -- Ciphertext to be decrypted in BASE64 string.
Output:
plaintext -- Plain data after decrypt and stored in BASE64 string.
*/
    async fn decrypt(&mut self, _keyid: &str, data_b64: &str, aad_b64: Option<&str>) -> Result<String>;
/*
Description:
Encrypt an arbitrary set of bytes using the CMK.(only support symmetric types).
Input:
keyid    -- The keyid of the cmk you want to use which must be a symmetric key.
aad_b64  -- Some extra datas input by the user, which could help to to ensure data integrity, 
            and not be included in the cipherblobs. The aad stored in BASE64 string.
data_b64 -- The datas of the plaintext which in based64 encoding.
Output:
ciphertext -- The result in json object for the Ciphertext which in based64 encoding.
*/
    async fn encrypt(&mut self, _keyid: &str, data_b64: &str, aad_b64: Option<&str>) -> Result<String>;
/*
Description:
The same as GenerateDataKey, but it doesnâ€™t return plaintext of generated DataKey.
Input:
keyid    -- A unique id of the specified symmetric CMK.
aad_b64  -- Some extra datas input by the user, which could help to to ensure data integrity, 
            and not be included in the cipherblobs. The aad stored in BASE64 string.
keylen   -- Specifies the length of the plaintext, length is 0~1024 bytes.
Output:
ciphertext  -- The cipher text of the data key stores in BASE64 string.
*/
    async fn generate_datakey_without_plaintext(&mut self, _keyid: &str, _len: &i32, aad_b64: Option<&str>)-> Result<String>;
/*
Description:
Generates a random data key that is used to locally encrypt data. 
the DataKey will be wrapped by the specified CMK(only support asymmetric keyspec), 
and it will return the plaintext and ciphertext of the data key.

You can use the plaintext of the data key to locally encrypt your data 
without using KMS and store the encrypted data together 
with the ciphertext of the data key, then clear the plaintext data from memory as soon as possible.

when you want to obtain the plaintext of datakey again, you can call the Decrypt with the cmk to get the plaintext data.
Input:
keyid    -- A unique id of the specified symmetric CMK.
aad_b64  -- Some extra datas input by the user, which could help to to ensure data integrity, 
            and not be included in the cipherblobs. The aad stored in BASE64 string.
keylen   -- Specifies the length of the plaintext, length is 0~1024 bytes.
Output:
ciphertext  -- The cipher text of the data key stores in BASE64 string.
*/
    async fn generate_datakey(&mut self, _keyid: &str, _len: &i32, aad_b64: Option<&str>)-> Result<String>;
/*
Description:
Encrypt an arbitrary set of bytes using the CMK.(only support asymmetric types).
Input:
keyid    -- A unique keyid for asymmetric key.
data_b64 -- The datas of the plaintext which in based64 encoding.
Output:
ciphertext -- The result in json object for the Ciphertext which in based64 encoding.
*/
    async fn asymmetric_encrypt(&mut self, _keyid: &str, data_b64: &str)-> Result<String>;
/*
Description:
Decrypt an arbitrary set of bytes using the CMK.(only support asymmetric types).
Input:
keyid    -- The keyid of the asymmetric cmk.
data_b64 -- The data of the ciphertext in BASE64 string.
Output:
plaintext -- Plaint data after decrypt and stored in BASE64 string.
*/  
    async fn asymmetric_decrypt(&mut self, _keyid: &str, data_b64: &str)-> Result<String>;
/*
Description:
ehsm-core enclave will decrypt user-supplied ciphertextblob with specified CMK to get the plaintext of DataKey, 
then use the user-supplied Public key to encrypt this DataKey(aka ExportedDataKey). 
This ExportedDataKey (ciphertext) will be returned to caller.
Input:
keyid    -- A unique id of the specified symmetric CMK.
ukeyid   -- The unique keyid of the asymmetric CMK which used to export.
aad_b64  -- Some extra datas input by the user, which could help to to ensure data integrity. 
            The aad stored in BASE64 string.
datakey  -- The ciphertext of the datakey wrapped by the cmk in BASE64 string.
Output:
newdatakey  -- The ciphertext of the datakey wrapped by the ukey stores in BASE64 string.
*/
    async fn export_datakey(&mut self, _keyid: &str, _ukeyid: &str, _datakey: &str, aad_b64: Option<&str>)-> Result<String>;
}
#[async_trait]
pub trait Secret {
    async fn create_secret(
        &mut self,
        secret_name: &str,
        secret_data: &str,
        encryption_key_id: Option<&str>,
        description: Option<&str>,
        rotation_interval: Option<u32>) -> Result<String>;
}